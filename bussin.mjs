var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// node_modules/currency-symbol-map/map.js
var require_map = __commonJS((exports, module) => {
  module.exports = {
    AED: "\u062F.\u0625",
    AFN: "\u060B",
    ALL: "L",
    AMD: "\u058F",
    ANG: "\u0192",
    AOA: "Kz",
    ARS: "$",
    AUD: "$",
    AWG: "\u0192",
    AZN: "\u20BC",
    BAM: "KM",
    BBD: "$",
    BDT: "\u09F3",
    BGN: "\u043B\u0432",
    BHD: ".\u062F.\u0628",
    BIF: "FBu",
    BMD: "$",
    BND: "$",
    BOB: "$b",
    BOV: "BOV",
    BRL: "R$",
    BSD: "$",
    BTC: "\u20BF",
    BTN: "Nu.",
    BWP: "P",
    BYN: "Br",
    BYR: "Br",
    BZD: "BZ$",
    CAD: "$",
    CDF: "FC",
    CHE: "CHE",
    CHF: "CHF",
    CHW: "CHW",
    CLF: "CLF",
    CLP: "$",
    CNH: "\xA5",
    CNY: "\xA5",
    COP: "$",
    COU: "COU",
    CRC: "\u20A1",
    CUC: "$",
    CUP: "\u20B1",
    CVE: "$",
    CZK: "K\u010D",
    DJF: "Fdj",
    DKK: "kr",
    DOP: "RD$",
    DZD: "\u062F\u062C",
    EEK: "kr",
    EGP: "\xA3",
    ERN: "Nfk",
    ETB: "Br",
    ETH: "\u039E",
    EUR: "\u20AC",
    FJD: "$",
    FKP: "\xA3",
    GBP: "\xA3",
    GEL: "\u20BE",
    GGP: "\xA3",
    GHC: "\u20B5",
    GHS: "GH\u20B5",
    GIP: "\xA3",
    GMD: "D",
    GNF: "FG",
    GTQ: "Q",
    GYD: "$",
    HKD: "$",
    HNL: "L",
    HRK: "kn",
    HTG: "G",
    HUF: "Ft",
    IDR: "Rp",
    ILS: "\u20AA",
    IMP: "\xA3",
    INR: "\u20B9",
    IQD: "\u0639.\u062F",
    IRR: "\uFDFC",
    ISK: "kr",
    JEP: "\xA3",
    JMD: "J$",
    JOD: "JD",
    JPY: "\xA5",
    KES: "KSh",
    KGS: "\u043B\u0432",
    KHR: "\u17DB",
    KMF: "CF",
    KPW: "\u20A9",
    KRW: "\u20A9",
    KWD: "KD",
    KYD: "$",
    KZT: "\u20B8",
    LAK: "\u20AD",
    LBP: "\xA3",
    LKR: "\u20A8",
    LRD: "$",
    LSL: "M",
    LTC: "\u0141",
    LTL: "Lt",
    LVL: "Ls",
    LYD: "LD",
    MAD: "MAD",
    MDL: "lei",
    MGA: "Ar",
    MKD: "\u0434\u0435\u043D",
    MMK: "K",
    MNT: "\u20AE",
    MOP: "MOP$",
    MRO: "UM",
    MRU: "UM",
    MUR: "\u20A8",
    MVR: "Rf",
    MWK: "MK",
    MXN: "$",
    MXV: "MXV",
    MYR: "RM",
    MZN: "MT",
    NAD: "$",
    NGN: "\u20A6",
    NIO: "C$",
    NOK: "kr",
    NPR: "\u20A8",
    NZD: "$",
    OMR: "\uFDFC",
    PAB: "B/.",
    PEN: "S/.",
    PGK: "K",
    PHP: "\u20B1",
    PKR: "\u20A8",
    PLN: "z\u0142",
    PYG: "Gs",
    QAR: "\uFDFC",
    RMB: "\uFFE5",
    RON: "lei",
    RSD: "\u0414\u0438\u043D.",
    RUB: "\u20BD",
    RWF: "R\u20A3",
    SAR: "\uFDFC",
    SBD: "$",
    SCR: "\u20A8",
    SDG: "\u062C.\u0633.",
    SEK: "kr",
    SGD: "S$",
    SHP: "\xA3",
    SLL: "Le",
    SOS: "S",
    SRD: "$",
    SSP: "\xA3",
    STD: "Db",
    STN: "Db",
    SVC: "$",
    SYP: "\xA3",
    SZL: "E",
    THB: "\u0E3F",
    TJS: "SM",
    TMT: "T",
    TND: "\u062F.\u062A",
    TOP: "T$",
    TRL: "\u20A4",
    TRY: "\u20BA",
    TTD: "TT$",
    TVD: "$",
    TWD: "NT$",
    TZS: "TSh",
    UAH: "\u20B4",
    UGX: "USh",
    USD: "$",
    UYI: "UYI",
    UYU: "$U",
    UYW: "UYW",
    UZS: "\u043B\u0432",
    VEF: "Bs",
    VES: "Bs.S",
    VND: "\u20AB",
    VUV: "VT",
    WST: "WS$",
    XAF: "FCFA",
    XBT: "\u0243",
    XCD: "$",
    XOF: "CFA",
    XPF: "\u20A3",
    XSU: "Sucre",
    XUA: "XUA",
    YER: "\uFDFC",
    ZAR: "R",
    ZMW: "ZK",
    ZWD: "Z$",
    ZWL: "$"
  };
});

// node_modules/currency-symbol-map/currency-symbol-map.js
var require_currency_symbol_map = __commonJS((exports, module) => {
  var currencySymbolMap = require_map();
  module.exports = function getSymbolFromCurrency(currencyCode) {
    if (typeof currencyCode !== "string") {
      return;
    }
    const code = currencyCode.toUpperCase();
    if (!Object.prototype.hasOwnProperty.call(currencySymbolMap, code)) {
      return;
    }
    return currencySymbolMap[code];
  };
  module.exports.currencySymbolMap = currencySymbolMap;
});

// src/frontend/lexer.ts
var token = function(value = "", type) {
  return { value, type };
};
var isalpha = function(src) {
  return /^[A-Za-z_]+$/.test(src);
};
var isskippable = function(str) {
  return str == " " || str == "\n" || str == "\t" || str == "\r";
};
var isint = function(str) {
  const c = str.charCodeAt(0);
  const bounds = ["0".charCodeAt(0), "9".charCodeAt(0)];
  return c >= bounds[0] && c <= bounds[1];
};
function tokenize(sourceCode) {
  const tokens = new Array;
  const src = sourceCode.split("");
  while (src.length > 0) {
    if (src[0] == "(") {
      tokens.push(token(src.shift(), TokenType.OpenParen));
    } else if (src[0] == "\\") {
      tokens.push(token(src.shift(), TokenType.Backslash));
    } else if (src[0] == ")") {
      tokens.push(token(src.shift(), TokenType.CloseParen));
    } else if (src[0] == "{") {
      tokens.push(token(src.shift(), TokenType.OpenBrace));
    } else if (src[0] == "}") {
      tokens.push(token(src.shift(), TokenType.CloseBrace));
    } else if (src[0] == "[") {
      tokens.push(token(src.shift(), TokenType.OpenBracket));
    } else if (src[0] == "]") {
      tokens.push(token(src.shift(), TokenType.CloseBracket));
    } else if (src[0] == "+" || src[0] == "-" || src[0] == "*" || src[0] == "%" || src[0] == "/") {
      tokens.push(token(src.shift(), TokenType.BinaryOperator));
    } else if (src[0] == "<") {
      tokens.push(token(src.shift(), TokenType.Lesser));
    } else if (src[0] == ">") {
      tokens.push(token(src.shift(), TokenType.Greater));
    } else if (src[0] == ".") {
      tokens.push(token(src.shift(), TokenType.Dot));
    } else if (src[0] == ";") {
      tokens.push(token(src.shift(), TokenType.Semicolon));
    } else if (src[0] == ":") {
      tokens.push(token(src.shift(), TokenType.Colon));
    } else if (src[0] == ",") {
      tokens.push(token(src.shift(), TokenType.Comma));
    } else if (src[0] == "|") {
      tokens.push(token(src.shift(), TokenType.Bar));
    } else {
      if (isint(src[0])) {
        let num = "";
        while (src.length > 0 && isint(src[0])) {
          num += src.shift();
        }
        tokens.push(token(num, TokenType.Number));
      } else if (src[0] == "=") {
        src.shift();
        if (src[0] == "=") {
          src.shift();
          tokens.push(token("==", TokenType.EqualsCompare));
        } else {
          tokens.push(token("=", TokenType.Equals));
        }
      } else if (src[0] == "&") {
        src.shift();
        if (src[0] == "&") {
          src.shift();
          tokens.push(token("&&", TokenType.And));
        } else {
          tokens.push(token("&", TokenType.Ampersand));
        }
      } else if (src[0] == "!") {
        src.shift();
        if (String(src[0]) == "=") {
          src.shift();
          tokens.push(token("!=", TokenType.NotEqualsCompare));
        } else {
          tokens.push(token("!", TokenType.Exclamation));
        }
      } else if (src[0] == '"') {
        let str = "";
        src.shift();
        while (src.length > 0 && src[0] !== '"') {
          str += src.shift();
        }
        src.shift();
        tokens.push(token(str, TokenType.String));
      } else if (isalpha(src[0])) {
        let ident = "";
        while (src.length > 0 && isalpha(src[0])) {
          ident += src.shift();
        }
        const reserved = KEYWORDS[ident];
        if (typeof reserved == "number") {
          tokens.push(token(ident, reserved));
        } else {
          tokens.push(token(ident, TokenType.Identifier));
        }
      } else if (isskippable(src[0])) {
        src.shift();
      } else {
        console.error("Unreconized character found in source: ", src[0].charCodeAt(0), src[0]);
        process.exit(1);
      }
    }
  }
  tokens.push({ type: TokenType.EOF, value: "EndOfFile" });
  return tokens;
}
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["Number"] = 0] = "Number";
  TokenType2[TokenType2["Identifier"] = 1] = "Identifier";
  TokenType2[TokenType2["String"] = 2] = "String";
  TokenType2[TokenType2["Let"] = 3] = "Let";
  TokenType2[TokenType2["Const"] = 4] = "Const";
  TokenType2[TokenType2["Fn"] = 5] = "Fn";
  TokenType2[TokenType2["If"] = 6] = "If";
  TokenType2[TokenType2["Else"] = 7] = "Else";
  TokenType2[TokenType2["For"] = 8] = "For";
  TokenType2[TokenType2["Backslash"] = 9] = "Backslash";
  TokenType2[TokenType2["BinaryOperator"] = 10] = "BinaryOperator";
  TokenType2[TokenType2["Equals"] = 11] = "Equals";
  TokenType2[TokenType2["Comma"] = 12] = "Comma";
  TokenType2[TokenType2["Colon"] = 13] = "Colon";
  TokenType2[TokenType2["Semicolon"] = 14] = "Semicolon";
  TokenType2[TokenType2["Dot"] = 15] = "Dot";
  TokenType2[TokenType2["OpenParen"] = 16] = "OpenParen";
  TokenType2[TokenType2["CloseParen"] = 17] = "CloseParen";
  TokenType2[TokenType2["OpenBrace"] = 18] = "OpenBrace";
  TokenType2[TokenType2["CloseBrace"] = 19] = "CloseBrace";
  TokenType2[TokenType2["OpenBracket"] = 20] = "OpenBracket";
  TokenType2[TokenType2["CloseBracket"] = 21] = "CloseBracket";
  TokenType2[TokenType2["Quotation"] = 22] = "Quotation";
  TokenType2[TokenType2["Greater"] = 23] = "Greater";
  TokenType2[TokenType2["Lesser"] = 24] = "Lesser";
  TokenType2[TokenType2["EqualsCompare"] = 25] = "EqualsCompare";
  TokenType2[TokenType2["NotEqualsCompare"] = 26] = "NotEqualsCompare";
  TokenType2[TokenType2["Exclamation"] = 27] = "Exclamation";
  TokenType2[TokenType2["And"] = 28] = "And";
  TokenType2[TokenType2["Ampersand"] = 29] = "Ampersand";
  TokenType2[TokenType2["Bar"] = 30] = "Bar";
  TokenType2[TokenType2["EOF"] = 31] = "EOF";
})(TokenType || (TokenType = {}));
var KEYWORDS = {
  let: TokenType.Let,
  const: TokenType.Const,
  fn: TokenType.Fn,
  if: TokenType.If,
  else: TokenType.Else,
  for: TokenType.For
};

// src/frontend/parser.ts
class Parser {
  tokens = [];
  not_eof() {
    return this.tokens[0].type != TokenType.EOF;
  }
  at() {
    return this.tokens[0];
  }
  eat() {
    const prev = this.tokens.shift();
    return prev;
  }
  expect(type, err) {
    const prev = this.tokens.shift();
    if (!prev || prev.type != type) {
      console.error(`Parser error:\n`, err, prev, "Expecting: ", type);
      process.exit(1);
    }
    return prev;
  }
  produceAST(sourceCode) {
    this.tokens = tokenize(sourceCode);
    const program = {
      kind: "Program",
      body: []
    };
    while (this.not_eof()) {
      program.body.push(this.parse_stmt());
    }
    return program;
  }
  parse_stmt() {
    switch (this.at().type) {
      case TokenType.Let:
      case TokenType.Const:
        return this.parse_var_declaration();
      case TokenType.Fn:
        return this.parse_function_declaration();
      case TokenType.If:
        return this.parse_if_statement();
      case TokenType.For:
        return this.parse_for_statement();
      default:
        return this.parse_expr();
    }
  }
  parse_block_statement() {
    this.expect(TokenType.OpenBrace, "Opening brace expected.");
    const body = [];
    while (this.not_eof() && this.at().type !== TokenType.CloseBrace) {
      const stmt = this.parse_stmt();
      body.push(stmt);
    }
    this.expect(TokenType.CloseBrace, "Closing brace expected.");
    return body;
  }
  parse_for_statement() {
    this.eat();
    this.expect(TokenType.OpenParen, "Expected opening parenthesis in while.");
    const init = this.parse_var_declaration();
    const test = this.parse_expr();
    this.expect(TokenType.Semicolon, "Expected semicolon following test expression in for statement");
    const update = this.parse_assignment_expr();
    this.expect(TokenType.CloseParen, "Expected closing paranthesis following additive expression in for statement");
    const body = this.parse_block_statement();
    return {
      kind: "ForStatement",
      init,
      test,
      update,
      body
    };
  }
  parse_if_statement() {
    this.eat();
    this.expect(TokenType.OpenParen, "Expected opening parenthesis following if keyword");
    const test = this.parse_expr();
    this.expect(TokenType.CloseParen, "Expected closing parenthesis following if keyword");
    const body = this.parse_block_statement();
    let alternate;
    if (this.at().type == TokenType.Else) {
      this.eat();
      if (this.at().type == TokenType.If) {
        alternate = [this.parse_if_statement()];
      } else {
        alternate = this.parse_block_statement();
      }
    }
    return {
      kind: "IfStatement",
      body,
      test,
      alternate
    };
  }
  parse_function_declaration() {
    this.eat();
    const name = this.expect(TokenType.Identifier, "Expected function name following fn keyword").value;
    const args = this.parse_args();
    const params = [];
    for (const arg of args) {
      if (arg.kind !== "Identifier") {
        throw "Inside function declaration expected parameters to be of type String";
      }
      params.push(arg.symbol);
    }
    const body = this.parse_block_statement();
    const fn = {
      body,
      name,
      parameters: params,
      kind: "FunctionDeclaration"
    };
    return fn;
  }
  parse_var_declaration() {
    const isConstant = this.eat().type == TokenType.Const;
    const identifier = this.expect(TokenType.Identifier, "Expected identifier name following let/const keywords.").value;
    if (this.at().type == TokenType.Semicolon) {
      this.eat();
      if (isConstant)
        throw "Must assign value to constant expression. No value provided.";
      return { kind: "VarDeclaration", identifier, constant: false, value: undefined };
    }
    this.expect(TokenType.Equals, "Expected equals token following identifier in var declaration.");
    const declaration = { kind: "VarDeclaration", value: this.parse_expr(), constant: isConstant, identifier };
    if (this.at().type == TokenType.String)
      this.eat();
    this.expect(TokenType.Semicolon, "Variable declaration statement must end in semicolon (\";\")");
    return declaration;
  }
  parse_expr() {
    return this.parse_assignment_expr();
  }
  parse_assignment_expr() {
    const left = this.parse_object_expr();
    if (this.at().type == TokenType.Equals) {
      this.eat();
      const value = this.parse_assignment_expr();
      return { value, assigne: left, kind: "AssignmentExpr" };
    }
    return left;
  }
  parse_and_statement() {
    let left = this.parse_additive_expr();
    if (["&&", "|"].includes(this.at().value)) {
      const operator = this.eat().value;
      const right = this.parse_additive_expr();
      left = {
        kind: "BinaryExpr",
        left,
        right,
        operator
      };
    }
    return left;
  }
  parse_try_catch_expr() {
    if (this.at().value !== "try") {
      return this.parse_and_statement();
    }
    this.eat();
    const body = this.parse_block_statement();
    if (this.at().value !== "catch")
      throw `Try statement must include a catch statement.`;
    this.eat();
    const alternate = this.parse_block_statement();
    return {
      kind: "TryCatchStatement",
      body,
      alternate
    };
  }
  parse_object_expr() {
    if (this.at().type !== TokenType.OpenBrace) {
      return this.parse_try_catch_expr();
    }
    this.eat();
    const properties = new Array;
    while (this.not_eof() && this.at().type != TokenType.CloseBrace) {
      const key = this.expect(TokenType.Identifier, "Object literal missing key.").value;
      if (this.at().type == TokenType.Comma) {
        this.eat();
        properties.push({ key, kind: "Property" });
        continue;
      } else if (this.at().type == TokenType.CloseBrace) {
        properties.push({ key, kind: "Property" });
        continue;
      }
      this.expect(TokenType.Colon, "Missing colon following identifier in object expression. (\",\")");
      const value = this.parse_expr();
      properties.push({ key, value, kind: "Property" });
      if (this.at().type != TokenType.CloseBrace) {
        this.expect(TokenType.Comma, "Expected comma or closing brace following property");
      }
    }
    this.expect(TokenType.CloseBrace, "Object literal missing closed brace. (\"}\")");
    return { kind: "ObjectLiteral", properties };
  }
  parse_additive_expr() {
    let left = this.parse_multiplicative_expr();
    while (["+", "-", "==", "!=", "<", ">"].includes(this.at().value)) {
      const operator = this.eat().value;
      const right = this.parse_multiplicative_expr();
      left = {
        kind: "BinaryExpr",
        left,
        right,
        operator
      };
    }
    return left;
  }
  parse_multiplicative_expr() {
    let left = this.parse_call_member_expr();
    while (["/", "*", "%"].includes(this.at().value)) {
      const operator = this.eat().value;
      const right = this.parse_call_member_expr();
      left = {
        kind: "BinaryExpr",
        left,
        right,
        operator
      };
    }
    return left;
  }
  parse_call_member_expr() {
    const member = this.parse_member_expr();
    if (this.at().type == TokenType.OpenParen) {
      return this.parse_call_expr(member);
    }
    return member;
  }
  parse_call_expr(caller) {
    let call_expr = {
      kind: "CallExpr",
      caller,
      args: this.parse_args()
    };
    if (this.at().type == TokenType.OpenParen) {
      call_expr = this.parse_call_expr(call_expr);
    }
    return call_expr;
  }
  parse_args() {
    this.expect(TokenType.OpenParen, "Expected open parenthesis");
    const args = this.at().type == TokenType.CloseParen ? [] : this.parse_args_list();
    this.expect(TokenType.CloseParen, "Missing closing parenthesis inside args list");
    return args;
  }
  parse_args_list() {
    const args = [this.parse_assignment_expr()];
    while (this.at().type == TokenType.Comma && this.eat()) {
      args.push(this.parse_assignment_expr());
    }
    return args;
  }
  parse_member_expr() {
    let object = this.parse_primary_expr();
    while (this.at().type == TokenType.Dot || this.at().type == TokenType.OpenBracket) {
      const operator = this.eat();
      let property;
      let computed;
      if (operator.type == TokenType.Dot) {
        computed = false;
        property = this.parse_primary_expr();
        if (property.kind !== "Identifier") {
          throw `Cannot use dot operator without right hand side being an identifier`;
        }
      } else {
        computed = true;
        property = this.parse_expr();
        this.expect(TokenType.CloseBracket, "Missing closing bracket in computed value.");
      }
      object = {
        kind: "MemberExpr",
        object,
        property,
        computed
      };
    }
    return object;
  }
  parse_primary_expr() {
    const tk = this.at().type;
    switch (tk) {
      case TokenType.Identifier:
        return { kind: "Identifier", symbol: this.eat().value };
      case TokenType.Number:
        return {
          kind: "NumericLiteral",
          value: parseFloat(this.eat().value)
        };
      case TokenType.String:
        return {
          kind: "StringLiteral",
          value: this.eat().value
        };
      case TokenType.OpenParen:
        this.eat();
        const value = this.parse_expr();
        this.expect(TokenType.CloseParen, "Unexpected token inside () expr. Expected \")\"");
        return value;
      default:
        console.error("Unexpected token found during parsing!", this.at());
        process.exit(1);
    }
  }
}

// src/runtime/environment.ts
import {execSync} from "child_process";

// src/runtime/eval/native-fns.ts
function printValues(args) {
  for (let i = 0;i < args.length; i++) {
    const arg = args[i];
    console.log(matchType(arg));
  }
}
function matchType(arg) {
  switch (arg.type) {
    case "string":
      return arg.value;
    case "number":
      return arg.value;
    case "boolean":
      return arg.value;
    case "null":
      return arg.value;
    case "object":
      let obj = {};
      const aObj = arg;
      aObj.properties.forEach((value, key) => {
        obj[key] = matchType(value);
      });
      return obj;
    case "fn":
      const fn = arg;
      return {
        name: fn.name,
        body: fn.body,
        internal: false
      };
    default:
      return arg;
  }
}

// src/runtime/values.ts
function MK_NATIVE_FN(call) {
  return { type: "native-fn", call };
}
function MK_NUMBER(n = 0) {
  return { type: "number", value: n };
}
function MK_NULL() {
  return { type: "null", value: null };
}
function MK_BOOL(b = true) {
  return { type: "boolean", value: b };
}
function MK_STRING(val) {
  return { type: "string", value: val };
}
function MK_OBJECT(obj) {
  return { type: "object", properties: obj };
}

// src/runtime/environment.ts
function createGlobalEnv() {
  const env = new Environment;
  env.declareVar("true", MK_BOOL(true), true);
  env.declareVar("false", MK_BOOL(false), true);
  env.declareVar("null", MK_NULL(), true);
  env.declareVar("error", MK_NULL(), false);
  env.declareVar("println", MK_NATIVE_FN((args) => {
    printValues(args);
    return MK_NULL();
  }), true);
  env.declareVar("exec", MK_NATIVE_FN((args) => {
    const cmd = args[0].value;
    try {
      const result = execSync(cmd, { encoding: "utf-8" });
      return MK_STRING(result.trim());
    } catch (error) {
      throw error;
    }
  }), true);
  env.declareVar("math", MK_OBJECT(new Map().set("pi", Math.PI).set("sqrt", MK_NATIVE_FN((args) => {
    const arg = args[0].value;
    return MK_NUMBER(Math.sqrt(arg));
  })).set("random", MK_NATIVE_FN((args) => {
    const arg1 = args[0].value;
    const arg2 = args[1].value;
    const min = Math.ceil(arg1);
    const max = Math.floor(arg2);
    return MK_NUMBER(Math.floor(Math.random() * (max - min + 1)) + min);
  })).set("round", MK_NATIVE_FN((args) => {
    const arg = args[0].value;
    return MK_NUMBER(Math.round(arg));
  })).set("ceil", MK_NATIVE_FN((args) => {
    const arg = args[0].value;
    return MK_NUMBER(Math.ceil(arg));
  })).set("abs", MK_NATIVE_FN((args) => {
    const arg = args[0].value;
    return MK_NUMBER(Math.abs(arg));
  }))), true);
  env.declareVar("strcon", MK_NATIVE_FN((args, env2) => {
    let res = "";
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      res += arg.value;
    }
    return MK_STRING(res);
  }), true);
  env.declareVar("format", MK_NATIVE_FN((args, env2) => {
    const str = args.shift();
    let res = "";
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      res = str.value.replace(/\${}/, arg.value);
    }
    if (!args[0])
      throw "2nd parameter in format! missing.";
    return MK_STRING(res);
  }), true);
  function timeFunction(args, env2) {
    return MK_NUMBER(Date.now());
  }
  env.declareVar("time", MK_NATIVE_FN(timeFunction), true);
  return env;
}

class Environment {
  parent;
  variables;
  constants;
  constructor(parentENV) {
    const global = parentENV ? true : false;
    this.parent = parentENV;
    this.variables = new Map;
    this.constants = new Set;
  }
  declareVar(varname, value, constant) {
    if (this.variables.has(varname)) {
      throw `Cannot declare variable ${varname}. As it already is defined.`;
    }
    this.variables.set(varname, value);
    if (constant)
      this.constants.add(varname);
    return value;
  }
  assignVar(varname, value) {
    const env = this.resolve(varname);
    if (env.constants.has(varname)) {
      throw `Cannot reassign to variable "${varname}" as it's constant.`;
    }
    env.variables.set(varname, value);
    return value;
  }
  lookupOrMutObject(expr, value, property) {
    if (expr.object.kind === "MemberExpr")
      return this.lookupOrMutObject(expr.object, value, expr.property);
    const varname = expr.object.symbol;
    const env = this.resolve(varname);
    let pastVal = env.variables.get(varname);
    const prop = property ? property.symbol : expr.property.symbol;
    const currentProp = expr.property.symbol;
    if (currentProp)
      pastVal = pastVal.properties.get(currentProp);
    if (value)
      pastVal.properties.set(prop, value);
    return pastVal;
  }
  lookupVar(varname) {
    const env = this.resolve(varname);
    return env.variables.get(varname);
  }
  resolve(varname) {
    if (this.variables.has(varname))
      return this;
    if (this.parent == undefined)
      throw `Cannot resolve '${varname}' as it does not exist.`;
    return this.parent.resolve(varname);
  }
}

// src/runtime/eval/expressions.ts
function eval_numeric_binary_expr(lhs, rhs, operator) {
  if (operator === "!=") {
    return equals(lhs, rhs, false);
  } else if (operator === "==") {
    return equals(lhs, rhs, true);
  } else if (operator === "&&") {
    return equals(lhs, rhs, true);
  } else if (operator === "|") {
    const llhs = lhs;
    const rrhs = rhs;
    return MK_BOOL(llhs.value || rrhs.value);
  } else if (lhs.type === "number" && rhs.type === "number") {
    const llhs = lhs;
    const rrhs = rhs;
    switch (operator) {
      case "+":
        return MK_NUMBER(llhs.value + rrhs.value);
      case "-":
        return MK_NUMBER(llhs.value - rrhs.value);
      case "*":
        return MK_NUMBER(llhs.value * rrhs.value);
      case "/":
        return MK_NUMBER(llhs.value / rrhs.value);
      case "%":
        return MK_NUMBER(llhs.value % rrhs.value);
      case "<":
        return MK_BOOL(llhs.value < rrhs.value);
      case ">":
        return MK_BOOL(llhs.value > rrhs.value);
      default:
        throw `Unknown operator provided in operation: ${lhs}, ${rhs}.`;
    }
  } else {
    return MK_NULL();
  }
}
var equals = function(lhs, rhs, strict) {
  const compare = strict ? (a, b) => a === b : (a, b) => a !== b;
  switch (lhs.type) {
    case "boolean":
      return MK_BOOL(compare(lhs.value, rhs.value));
    case "number":
      return MK_BOOL(compare(lhs.value, rhs.value));
    case "string":
      return MK_BOOL(compare(lhs.value, rhs.value));
    case "fn":
      return MK_BOOL(compare(lhs.body, rhs.body));
    case "native-fn":
      return MK_BOOL(compare(lhs.call, rhs.call));
    case "null":
      return MK_BOOL(compare(lhs.value, rhs.value));
    case "object":
      return MK_BOOL(compare(lhs.properties, rhs.properties));
    default:
      throw `Unhandled type in: ${lhs}, ${rhs}`;
  }
};
function eval_binary_expr(binop, env) {
  const lhs = evaluate(binop.left, env);
  const rhs = evaluate(binop.right, env);
  return eval_numeric_binary_expr(lhs, rhs, binop.operator);
}
function eval_identifier(ident, env) {
  const val = env.lookupVar(ident.symbol);
  return val;
}
function eval_assignment(node, env) {
  if (node.assigne.kind === "MemberExpr")
    return eval_member_expr(env, node);
  if (node.assigne.kind !== "Identifier")
    throw `Invalid left-hand-side expression: ${JSON.stringify(node.assigne)}.`;
  const varname = node.assigne.symbol;
  return env.assignVar(varname, evaluate(node.value, env));
}
function eval_object_expr(obj, env) {
  const object = { type: "object", properties: new Map };
  for (const { key, value } of obj.properties) {
    const runtimeVal = value == undefined ? env.lookupVar(key) : evaluate(value, env);
    object.properties.set(key, runtimeVal);
  }
  return object;
}
function eval_call_expr(expr, env) {
  const args = expr.args.map((arg) => evaluate(arg, env));
  const fn = evaluate(expr.caller, env);
  if (fn.type == "native-fn") {
    const result = fn.call(args, env);
    return result;
  }
  if (fn.type == "fn") {
    const func = fn;
    const scope = new Environment(func.declarationEnv);
    for (let i = 0;i < func.parameters.length; i++) {
      const varname = func.parameters[i];
      scope.declareVar(varname, args[i], false);
    }
    let result = MK_NULL();
    for (const stmt of func.body) {
      result = evaluate(stmt, scope);
    }
    return result;
  }
  throw "Cannot call value that is not a function: " + JSON.stringify(fn);
}
function eval_member_expr(env, node, expr) {
  if (expr) {
    const variable = env.lookupOrMutObject(expr);
    return variable;
  } else if (node) {
    const variable = env.lookupOrMutObject(node.assigne, evaluate(node.value, env));
    return variable;
  } else {
    throw `Evaluating a member expression is not possible without a member or assignment expression.`;
  }
}

// src/runtime/eval/statements.ts
function eval_program(program, env) {
  let lastEvaluated = MK_NULL();
  for (const statement of program.body) {
    lastEvaluated = evaluate(statement, env);
  }
  return lastEvaluated;
}
function eval_val_declaration(declaration, env) {
  const value = declaration.value ? evaluate(declaration.value, env) : MK_NULL();
  return env.declareVar(declaration.identifier, value, declaration.constant);
}
function eval_function_declaration(declaration, env) {
  const fn = {
    type: "fn",
    name: declaration.name,
    parameters: declaration.parameters,
    declarationEnv: env,
    body: declaration.body
  };
  return env.declareVar(declaration.name, fn, true);
}
function eval_if_statement(declaration, env) {
  const test = evaluate(declaration.test, env);
  if (test.value === true) {
    return eval_body(declaration.body, env);
  } else if (declaration.alternate) {
    return eval_body(declaration.alternate, env);
  } else {
    return MK_NULL();
  }
}
var eval_body = function(body, env, newEnv = true) {
  let scope;
  if (newEnv) {
    scope = new Environment(env);
  } else {
    scope = env;
  }
  let result = MK_NULL();
  for (const stmt of body) {
    result = evaluate(stmt, scope);
  }
  return result;
};
function eval_for_statement(declaration, env) {
  env = new Environment(env);
  eval_val_declaration(declaration.init, env);
  const body = declaration.body;
  const update = declaration.update;
  let test = evaluate(declaration.test, env);
  if (test.value !== true)
    return MK_NULL();
  do {
    eval_assignment(update, env);
    eval_body(body, env, false);
    test = evaluate(declaration.test, env);
  } while (test.value);
  return MK_NULL();
}
function eval_try_catch_statement(env, declaration) {
  const try_env = new Environment(env);
  const catch_env = new Environment(env);
  try {
    return eval_body(declaration.body, try_env, false);
  } catch (e) {
    env.assignVar("error", e);
    return eval_body(declaration.alternate, catch_env, false);
  }
}

// src/runtime/interpreter.ts
function evaluate(astNode, env) {
  switch (astNode.kind) {
    case "NumericLiteral":
      return { value: astNode.value, type: "number" };
    case "StringLiteral":
      return { value: astNode.value, type: "string" };
    case "Identifier":
      return eval_identifier(astNode, env);
    case "ObjectLiteral":
      return eval_object_expr(astNode, env);
    case "CallExpr":
      return eval_call_expr(astNode, env);
    case "AssignmentExpr":
      return eval_assignment(astNode, env);
    case "BinaryExpr":
      return eval_binary_expr(astNode, env);
    case "Program":
      return eval_program(astNode, env);
    case "IfStatement":
      return eval_if_statement(astNode, env);
    case "ForStatement":
      return eval_for_statement(astNode, env);
    case "MemberExpr":
      return eval_member_expr(env, null, astNode);
    case "TryCatchStatement":
      return eval_try_catch_statement(env, astNode);
    case "VarDeclaration":
      return eval_val_declaration(astNode, env);
    case "FunctionDeclaration":
      return eval_function_declaration(astNode, env);
    default:
      console.error("This AST node has not yet been setup for interpretation", astNode);
      process.exit(0);
  }
}

// src/main.ts
import * as readline from "readline/promises";
import {readFileSync} from "fs";

// src/utils/currency.ts
var import_currency_symbol_map = __toESM(require_currency_symbol_map(), 1);
async function getLocalCurrency() {
  const cSymbol = await (await fetch("https://ipapi.co/currency/")).text();
  return import_currency_symbol_map.default(cSymbol);
}

// src/utils/transcriber.ts
async function transcribe(code, bsx) {
  const currency2 = await getLocalCurrency();
  if (bsx) {
    return code.replace_fr("rn", ";").replace_fr(";", "!").replace_fr("be", "=").replace_fr("lit", "let").replace_fr("mf", "const").replace_fr("waffle", "println").replace_fr("sus", "if").replace_fr("impostor", "else").replace_fr("nah", "!=").replace_fr("fr", "==").replace_fr("btw", "&&").replace_fr("carenot", "|").replace_fr("bruh", "fn").replace_fr("nerd", "math").replace_fr("yall", "for").replace_fr("smol", "<").replace_fr("thicc", ">").replace_fr("nocap", "true").replace_fr("cap", "false").replace_fr("fuck_around", "try").replace_fr("find_out", "catch").replace_fr("clapback", "exec").replace_fr("result", "=").replace_fr("minus", "-").replace_fr("plus", "+").replace_fr("times", "*").replace_fr("divided by", "/").replace(/\: number/g, "").replace(/\: string/g, "").replace(/\: object/g, "").replace(/\: boolean/g, "").replace(new RegExp(`${currency2}{}`), "${}").replace(new RegExp(`{}${currency2}`), "${}");
  } else {
    return code.replace(/\: number/g, "").replace(/\: string/g, "").replace(/\: object/g, "").replace(/\: boolean/g, "").replace(new RegExp(`${currency2}{}`), "${}").replace(new RegExp(`{}${currency2}`), "${}");
  }
}
String.prototype.replace_fr = function(target, replacement) {
  const pattern = new RegExp('(?<![\'"`])\\b' + target + '\\b(?!["\'`])', "g");
  return this.replace(pattern, replacement);
};

// src/main.ts
async function run(filename) {
  await fetch("https://8.8.8.8");
  const parser2 = new Parser;
  const env = createGlobalEnv();
  let input = readFileSync(filename, "utf-8");
  filename.endsWith(".bsx") ? input = await transcribe(input, true) : input = await transcribe(input, false);
  const program = parser2.produceAST(input);
  const result = evaluate(program, env);
  return result;
}
async function repl(arg) {
  await fetch("https://8.8.8.8");
  const parser2 = new Parser;
  const env = createGlobalEnv();
  console.log("Repl v1.0 (Bussin)");
  while (true) {
    let input = await rl.question("> ");
    if (!input || input.includes("exit")) {
      process.exit(1);
    }
    input = await transcribe(input, arg !== "--bsx" ? false : true);
    const program = parser2.produceAST(input);
    const result = evaluate(program, env);
    console.log(result);
  }
}
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
var file = process.argv[2] && !process.argv[2].startsWith("-") && process.argv[2];
if (file) {
  run(file);
} else if (process.argv[2]) {
  repl(process.argv[2]);
} else {
  repl();
}
