var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// node_modules/currency-symbol-map/map.js
var require_map = __commonJS((exports, module) => {
  module.exports = {
    AED: "\u062F.\u0625",
    AFN: "\u060B",
    ALL: "L",
    AMD: "\u058F",
    ANG: "\u0192",
    AOA: "Kz",
    ARS: "$",
    AUD: "$",
    AWG: "\u0192",
    AZN: "\u20BC",
    BAM: "KM",
    BBD: "$",
    BDT: "\u09F3",
    BGN: "\u043B\u0432",
    BHD: ".\u062F.\u0628",
    BIF: "FBu",
    BMD: "$",
    BND: "$",
    BOB: "$b",
    BOV: "BOV",
    BRL: "R$",
    BSD: "$",
    BTC: "\u20BF",
    BTN: "Nu.",
    BWP: "P",
    BYN: "Br",
    BYR: "Br",
    BZD: "BZ$",
    CAD: "$",
    CDF: "FC",
    CHE: "CHE",
    CHF: "CHF",
    CHW: "CHW",
    CLF: "CLF",
    CLP: "$",
    CNH: "\xA5",
    CNY: "\xA5",
    COP: "$",
    COU: "COU",
    CRC: "\u20A1",
    CUC: "$",
    CUP: "\u20B1",
    CVE: "$",
    CZK: "K\u010D",
    DJF: "Fdj",
    DKK: "kr",
    DOP: "RD$",
    DZD: "\u062F\u062C",
    EEK: "kr",
    EGP: "\xA3",
    ERN: "Nfk",
    ETB: "Br",
    ETH: "\u039E",
    EUR: "\u20AC",
    FJD: "$",
    FKP: "\xA3",
    GBP: "\xA3",
    GEL: "\u20BE",
    GGP: "\xA3",
    GHC: "\u20B5",
    GHS: "GH\u20B5",
    GIP: "\xA3",
    GMD: "D",
    GNF: "FG",
    GTQ: "Q",
    GYD: "$",
    HKD: "$",
    HNL: "L",
    HRK: "kn",
    HTG: "G",
    HUF: "Ft",
    IDR: "Rp",
    ILS: "\u20AA",
    IMP: "\xA3",
    INR: "\u20B9",
    IQD: "\u0639.\u062F",
    IRR: "\uFDFC",
    ISK: "kr",
    JEP: "\xA3",
    JMD: "J$",
    JOD: "JD",
    JPY: "\xA5",
    KES: "KSh",
    KGS: "\u043B\u0432",
    KHR: "\u17DB",
    KMF: "CF",
    KPW: "\u20A9",
    KRW: "\u20A9",
    KWD: "KD",
    KYD: "$",
    KZT: "\u20B8",
    LAK: "\u20AD",
    LBP: "\xA3",
    LKR: "\u20A8",
    LRD: "$",
    LSL: "M",
    LTC: "\u0141",
    LTL: "Lt",
    LVL: "Ls",
    LYD: "LD",
    MAD: "MAD",
    MDL: "lei",
    MGA: "Ar",
    MKD: "\u0434\u0435\u043D",
    MMK: "K",
    MNT: "\u20AE",
    MOP: "MOP$",
    MRO: "UM",
    MRU: "UM",
    MUR: "\u20A8",
    MVR: "Rf",
    MWK: "MK",
    MXN: "$",
    MXV: "MXV",
    MYR: "RM",
    MZN: "MT",
    NAD: "$",
    NGN: "\u20A6",
    NIO: "C$",
    NOK: "kr",
    NPR: "\u20A8",
    NZD: "$",
    OMR: "\uFDFC",
    PAB: "B/.",
    PEN: "S/.",
    PGK: "K",
    PHP: "\u20B1",
    PKR: "\u20A8",
    PLN: "z\u0142",
    PYG: "Gs",
    QAR: "\uFDFC",
    RMB: "\uFFE5",
    RON: "lei",
    RSD: "\u0414\u0438\u043D.",
    RUB: "\u20BD",
    RWF: "R\u20A3",
    SAR: "\uFDFC",
    SBD: "$",
    SCR: "\u20A8",
    SDG: "\u062C.\u0633.",
    SEK: "kr",
    SGD: "S$",
    SHP: "\xA3",
    SLL: "Le",
    SOS: "S",
    SRD: "$",
    SSP: "\xA3",
    STD: "Db",
    STN: "Db",
    SVC: "$",
    SYP: "\xA3",
    SZL: "E",
    THB: "\u0E3F",
    TJS: "SM",
    TMT: "T",
    TND: "\u062F.\u062A",
    TOP: "T$",
    TRL: "\u20A4",
    TRY: "\u20BA",
    TTD: "TT$",
    TVD: "$",
    TWD: "NT$",
    TZS: "TSh",
    UAH: "\u20B4",
    UGX: "USh",
    USD: "$",
    UYI: "UYI",
    UYU: "$U",
    UYW: "UYW",
    UZS: "\u043B\u0432",
    VEF: "Bs",
    VES: "Bs.S",
    VND: "\u20AB",
    VUV: "VT",
    WST: "WS$",
    XAF: "FCFA",
    XBT: "\u0243",
    XCD: "$",
    XOF: "CFA",
    XPF: "\u20A3",
    XSU: "Sucre",
    XUA: "XUA",
    YER: "\uFDFC",
    ZAR: "R",
    ZMW: "ZK",
    ZWD: "Z$",
    ZWL: "$"
  };
});

// node_modules/currency-symbol-map/currency-symbol-map.js
var require_currency_symbol_map = __commonJS((exports, module) => {
  var currencySymbolMap = require_map();
  module.exports = function getSymbolFromCurrency(currencyCode) {
    if (typeof currencyCode !== "string") {
      return;
    }
    const code = currencyCode.toUpperCase();
    if (!Object.prototype.hasOwnProperty.call(currencySymbolMap, code)) {
      return;
    }
    return currencySymbolMap[code];
  };
  module.exports.currencySymbolMap = currencySymbolMap;
});

// src/frontend/lexer.ts
var token = function(value = "", type) {
  return { value, type };
};
var isalpha = function(src) {
  return /^[A-Za-z_]+$/.test(src);
};
var isskippable = function(str) {
  return str == " " || str == "\n" || str == "\t" || str == "\r";
};
var isint = function(str) {
  const c = str.charCodeAt(0);
  const bounds = ["0".charCodeAt(0), "9".charCodeAt(0)];
  return c >= bounds[0] && c <= bounds[1];
};
function tokenize(sourceCode) {
  const tokens = new Array;
  const src = sourceCode.split("");
  while (src.length > 0) {
    if (src[0] == "(") {
      tokens.push(token(src.shift(), TokenType.OpenParen));
    } else if (src[0] == "\\") {
      tokens.push(token(src.shift(), TokenType.Backslash));
    } else if (src[0] == ")") {
      tokens.push(token(src.shift(), TokenType.CloseParen));
    } else if (src[0] == "{") {
      tokens.push(token(src.shift(), TokenType.OpenBrace));
    } else if (src[0] == "}") {
      tokens.push(token(src.shift(), TokenType.CloseBrace));
    } else if (src[0] == "[") {
      tokens.push(token(src.shift(), TokenType.OpenBracket));
    } else if (src[0] == "]") {
      tokens.push(token(src.shift(), TokenType.CloseBracket));
    } else if (src[0] == "+" || src[0] == "-" || src[0] == "*" || src[0] == "%" || src[0] == "/") {
      tokens.push(token(src.shift(), TokenType.BinaryOperator));
    } else if (src[0] == "<") {
      tokens.push(token(src.shift(), TokenType.Lesser));
    } else if (src[0] == ">") {
      tokens.push(token(src.shift(), TokenType.Greater));
    } else if (src[0] == ".") {
      tokens.push(token(src.shift(), TokenType.Dot));
    } else if (src[0] == ";") {
      tokens.push(token(src.shift(), TokenType.Semicolon));
    } else if (src[0] == ":") {
      tokens.push(token(src.shift(), TokenType.Colon));
    } else if (src[0] == ",") {
      tokens.push(token(src.shift(), TokenType.Comma));
    } else if (src[0] == "|") {
      tokens.push(token(src.shift(), TokenType.Bar));
    } else {
      if (isint(src[0])) {
        let num = "";
        while (src.length > 0 && isint(src[0])) {
          num += src.shift();
        }
        tokens.push(token(num, TokenType.Number));
      } else if (src[0] == "=") {
        src.shift();
        if (src[0] == "=") {
          src.shift();
          tokens.push(token("==", TokenType.EqualsCompare));
        } else {
          tokens.push(token("=", TokenType.Equals));
        }
      } else if (src[0] == "&") {
        src.shift();
        if (src[0] == "&") {
          src.shift();
          tokens.push(token("&&", TokenType.And));
        } else {
          tokens.push(token("&", TokenType.Ampersand));
        }
      } else if (src[0] == "!") {
        src.shift();
        if (String(src[0]) == "=") {
          src.shift();
          tokens.push(token("!=", TokenType.NotEqualsCompare));
        } else {
          tokens.push(token("!", TokenType.Exclamation));
        }
      } else if (src[0] == '"') {
        let str = "";
        src.shift();
        while (src.length > 0 && src[0] !== '"') {
          str += src.shift();
        }
        src.shift();
        tokens.push(token(str, TokenType.String));
      } else if (isalpha(src[0])) {
        let ident = "";
        while (src.length > 0 && isalpha(src[0])) {
          ident += src.shift();
        }
        const reserved = KEYWORDS[ident];
        if (typeof reserved == "number") {
          tokens.push(token(ident, reserved));
        } else {
          tokens.push(token(ident, TokenType.Identifier));
        }
      } else if (isskippable(src[0])) {
        src.shift();
      } else {
        console.error("Unreconized character found in source: ", src[0].charCodeAt(0), src[0]);
        process.exit(1);
      }
    }
  }
  tokens.push({ type: TokenType.EOF, value: "EndOfFile" });
  return tokens;
}
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["Number"] = 0] = "Number";
  TokenType2[TokenType2["Identifier"] = 1] = "Identifier";
  TokenType2[TokenType2["String"] = 2] = "String";
  TokenType2[TokenType2["Let"] = 3] = "Let";
  TokenType2[TokenType2["Const"] = 4] = "Const";
  TokenType2[TokenType2["Fn"] = 5] = "Fn";
  TokenType2[TokenType2["If"] = 6] = "If";
  TokenType2[TokenType2["Else"] = 7] = "Else";
  TokenType2[TokenType2["For"] = 8] = "For";
  TokenType2[TokenType2["Backslash"] = 9] = "Backslash";
  TokenType2[TokenType2["BinaryOperator"] = 10] = "BinaryOperator";
  TokenType2[TokenType2["Equals"] = 11] = "Equals";
  TokenType2[TokenType2["Comma"] = 12] = "Comma";
  TokenType2[TokenType2["Colon"] = 13] = "Colon";
  TokenType2[TokenType2["Semicolon"] = 14] = "Semicolon";
  TokenType2[TokenType2["Dot"] = 15] = "Dot";
  TokenType2[TokenType2["OpenParen"] = 16] = "OpenParen";
  TokenType2[TokenType2["CloseParen"] = 17] = "CloseParen";
  TokenType2[TokenType2["OpenBrace"] = 18] = "OpenBrace";
  TokenType2[TokenType2["CloseBrace"] = 19] = "CloseBrace";
  TokenType2[TokenType2["OpenBracket"] = 20] = "OpenBracket";
  TokenType2[TokenType2["CloseBracket"] = 21] = "CloseBracket";
  TokenType2[TokenType2["Quotation"] = 22] = "Quotation";
  TokenType2[TokenType2["Greater"] = 23] = "Greater";
  TokenType2[TokenType2["Lesser"] = 24] = "Lesser";
  TokenType2[TokenType2["EqualsCompare"] = 25] = "EqualsCompare";
  TokenType2[TokenType2["NotEqualsCompare"] = 26] = "NotEqualsCompare";
  TokenType2[TokenType2["Exclamation"] = 27] = "Exclamation";
  TokenType2[TokenType2["And"] = 28] = "And";
  TokenType2[TokenType2["Ampersand"] = 29] = "Ampersand";
  TokenType2[TokenType2["Bar"] = 30] = "Bar";
  TokenType2[TokenType2["EOF"] = 31] = "EOF";
})(TokenType || (TokenType = {}));
var KEYWORDS = {
  let: TokenType.Let,
  const: TokenType.Const,
  fn: TokenType.Fn,
  if: TokenType.If,
  else: TokenType.Else,
  for: TokenType.For
};

// src/frontend/parser.ts
class Parser {
  tokens = [];
  not_eof() {
    return this.tokens[0].type != TokenType.EOF;
  }
  at() {
    return this.tokens[0];
  }
  eat() {
    const prev = this.tokens.shift();
    return prev;
  }
  expect(type, err) {
    const prev = this.tokens.shift();
    if (!prev || prev.type != type) {
      console.error(`Parser error:\n`, err, prev, "Expecting: ", type);
      process.exit(1);
    }
    return prev;
  }
  produceAST(sourceCode) {
    this.tokens = tokenize(sourceCode);
    const program = {
      kind: "Program",
      body: []
    };
    while (this.not_eof()) {
      program.body.push(this.parse_stmt());
    }
    return program;
  }
  parse_stmt() {
    switch (this.at().type) {
      case TokenType.Let:
      case TokenType.Const:
        return this.parse_var_declaration();
      case TokenType.Fn:
        return this.parse_function_declaration();
      case TokenType.If:
        return this.parse_if_statement();
      case TokenType.For:
        return this.parse_for_statement();
      default:
        return this.parse_expr();
    }
  }
  parse_block_statement() {
    this.expect(TokenType.OpenBrace, "Opening brace expected.");
    const body = [];
    while (this.not_eof() && this.at().type !== TokenType.CloseBrace) {
      const stmt = this.parse_stmt();
      body.push(stmt);
    }
    this.expect(TokenType.CloseBrace, "Closing brace expected.");
    return body;
  }
  parse_for_statement() {
    this.eat();
    this.expect(TokenType.OpenParen, "Expected opening parenthesis in while.");
    const init = this.parse_var_declaration();
    const test = this.parse_expr();
    this.expect(TokenType.Semicolon, "Expected semicolon following test expression in for statement");
    const update = this.parse_assignment_expr();
    this.expect(TokenType.CloseParen, "Expected closing paranthesis following additive expression in for statement");
    const body = this.parse_block_statement();
    return {
      kind: "ForStatement",
      init,
      test,
      update,
      body
    };
  }
  parse_if_statement() {
    this.eat();
    this.expect(TokenType.OpenParen, "Expected opening parenthesis following if keyword");
    const test = this.parse_expr();
    this.expect(TokenType.CloseParen, "Expected closing parenthesis following if keyword");
    const body = this.parse_block_statement();
    let alternate;
    if (this.at().type == TokenType.Else) {
      this.eat();
      if (this.at().type == TokenType.If) {
        alternate = [this.parse_if_statement()];
      } else {
        alternate = this.parse_block_statement();
      }
    }
    return {
      kind: "IfStatement",
      body,
      test,
      alternate
    };
  }
  parse_function_declaration() {
    this.eat();
    const name = this.expect(TokenType.Identifier, "Expected function name following fn keyword").value;
    const args = this.parse_args();
    const params = [];
    for (const arg of args) {
      if (arg.kind !== "Identifier") {
        throw "Inside function declaration expected parameters to be of type String";
      }
      params.push(arg.symbol);
    }
    const body = this.parse_block_statement();
    const fn = {
      body,
      name,
      parameters: params,
      kind: "FunctionDeclaration"
    };
    return fn;
  }
  parse_var_declaration() {
    const isConstant = this.eat().type == TokenType.Const;
    const identifier = this.expect(TokenType.Identifier, "Expected identifier name following let/const keywords.").value;
    if (this.at().type == TokenType.Semicolon) {
      this.eat();
      if (isConstant)
        throw "Must assign value to constant expression. No value provided.";
      return { kind: "VarDeclaration", identifier, constant: false, value: undefined };
    }
    this.expect(TokenType.Equals, "Expected equals token following identifier in var declaration.");
    const declaration = { kind: "VarDeclaration", value: this.parse_expr(), constant: isConstant, identifier };
    if (this.at().type == TokenType.String)
      this.eat();
    this.expect(TokenType.Semicolon, "Variable declaration statement must end in semicolon (\";\")");
    return declaration;
  }
  parse_expr() {
    return this.parse_assignment_expr();
  }
  parse_assignment_expr() {
    const left = this.parse_object_expr();
    if (this.at().type == TokenType.Equals) {
      this.eat();
      const value = this.parse_assignment_expr();
      return { value, assigne: left, kind: "AssignmentExpr" };
    }
    return left;
  }
  parse_and_statement() {
    let left = this.parse_additive_expr();
    if (["&&", "|"].includes(this.at().value)) {
      const operator = this.eat().value;
      const right = this.parse_additive_expr();
      left = {
        kind: "BinaryExpr",
        left,
        right,
        operator
      };
    }
    return left;
  }
  parse_try_catch_expr() {
    if (this.at().value !== "try") {
      return this.parse_and_statement();
    }
    this.eat();
    const body = this.parse_block_statement();
    if (this.at().value !== "catch")
      throw `Try statement must include a catch statement.`;
    this.eat();
    const alternate = this.parse_block_statement();
    return {
      kind: "TryCatchStatement",
      body,
      alternate
    };
  }
  parse_object_expr() {
    if (this.at().type !== TokenType.OpenBrace) {
      return this.parse_try_catch_expr();
    }
    this.eat();
    const properties = new Array;
    while (this.not_eof() && this.at().type != TokenType.CloseBrace) {
      const key = this.expect(TokenType.Identifier, "Object literal missing key.").value;
      if (this.at().type == TokenType.Comma) {
        this.eat();
        properties.push({ key, kind: "Property" });
        continue;
      } else if (this.at().type == TokenType.CloseBrace) {
        properties.push({ key, kind: "Property" });
        continue;
      }
      this.expect(TokenType.Colon, "Missing colon following identifier in object expression. (\",\")");
      const value = this.parse_expr();
      properties.push({ key, value, kind: "Property" });
      if (this.at().type != TokenType.CloseBrace) {
        this.expect(TokenType.Comma, "Expected comma or closing brace following property");
      }
    }
    this.expect(TokenType.CloseBrace, "Object literal missing closed brace. (\"}\")");
    return { kind: "ObjectLiteral", properties };
  }
  parse_additive_expr() {
    let left = this.parse_multiplicative_expr();
    while (["+", "-", "==", "!=", "<", ">"].includes(this.at().value)) {
      const operator = this.eat().value;
      const right = this.parse_multiplicative_expr();
      left = {
        kind: "BinaryExpr",
        left,
        right,
        operator
      };
    }
    return left;
  }
  parse_multiplicative_expr() {
    let left = this.parse_call_member_expr();
    while (["/", "*", "%"].includes(this.at().value)) {
      const operator = this.eat().value;
      const right = this.parse_call_member_expr();
      left = {
        kind: "BinaryExpr",
        left,
        right,
        operator
      };
    }
    return left;
  }
  parse_call_member_expr() {
    const member = this.parse_member_expr();
    if (this.at().type == TokenType.OpenParen) {
      return this.parse_call_expr(member);
    }
    return member;
  }
  parse_call_expr(caller) {
    let call_expr = {
      kind: "CallExpr",
      caller,
      args: this.parse_args()
    };
    if (this.at().type == TokenType.OpenParen) {
      call_expr = this.parse_call_expr(call_expr);
    }
    return call_expr;
  }
  parse_args() {
    this.expect(TokenType.OpenParen, "Expected open parenthesis");
    const args = this.at().type == TokenType.CloseParen ? [] : this.parse_args_list();
    this.expect(TokenType.CloseParen, "Missing closing parenthesis inside args list");
    return args;
  }
  parse_args_list() {
    const args = [this.parse_assignment_expr()];
    while (this.at().type == TokenType.Comma && this.eat()) {
      args.push(this.parse_assignment_expr());
    }
    return args;
  }
  parse_member_expr() {
    let object = this.parse_primary_expr();
    while (this.at().type == TokenType.Dot || this.at().type == TokenType.OpenBracket) {
      const operator = this.eat();
      let property;
      let computed;
      if (operator.type == TokenType.Dot) {
        computed = false;
        property = this.parse_primary_expr();
        if (property.kind !== "Identifier") {
          throw `Cannot use dot operator without right hand side being an identifier`;
        }
      } else {
        computed = true;
        property = this.parse_expr();
        this.expect(TokenType.CloseBracket, "Missing closing bracket in computed value.");
      }
      object = {
        kind: "MemberExpr",
        object,
        property,
        computed
      };
    }
    return object;
  }
  parse_primary_expr() {
    const tk = this.at().type;
    switch (tk) {
      case TokenType.Identifier:
        return { kind: "Identifier", symbol: this.eat().value };
      case TokenType.Number:
        return {
          kind: "NumericLiteral",
          value: parseFloat(this.eat().value)
        };
      case TokenType.String:
        return {
          kind: "StringLiteral",
          value: this.eat().value
        };
      case TokenType.OpenParen:
        this.eat();
        const value = this.parse_expr();
        this.expect(TokenType.CloseParen, "Unexpected token inside () expr. Expected \")\"");
        return value;
      default:
        console.error("Unexpected token found during parsing!", this.at());
        process.exit(1);
    }
  }
}

// src/runtime/environment.ts
import {execSync} from "child_process";

// src/runtime/eval/native-fns.ts
function printValues(args) {
  for (let i = 0;i < args.length; i++) {
    const arg = args[i];
    console.log(matchType(arg));
  }
}
function matchType(arg) {
  switch (arg.type) {
    case "string":
      return arg.value;
    case "number":
      return arg.value;
    case "boolean":
      return arg.value;
    case "null":
      return arg.value;
    case "object":
      let obj = {};
      const aObj = arg;
      aObj.properties.forEach((value, key) => {
        obj[key] = matchType(value);
      });
      return obj;
    case "fn":
      const fn = arg;
      return {
        name: fn.name,
        body: fn.body,
        internal: false
      };
    default:
      return arg;
  }
}

// src/runtime/values.ts
function MK_NATIVE_FN(call) {
  return { type: "native-fn", call };
}
function MK_NUMBER(n = 0) {
  return { type: "number", value: n };
}
function MK_NULL() {
  return { type: "null", value: null };
}
function MK_BOOL(b = true) {
  return { type: "boolean", value: b };
}
function MK_STRING(val) {
  return { type: "string", value: val };
}
function MK_OBJECT(obj) {
  return { type: "object", properties: obj };
}

// src/utils/stdin.ts
import * as readline from "node:readline/promises";
async function getSTDIN(prompt) {
  return await Manager.prototype.rl.question(prompt);
}

class Manager {
  rl;
}
Manager.prototype.rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
getSTDIN.closed = false;
getSTDIN.close = function close() {
  Manager.prototype.rl.close();
  getSTDIN.closed = true;
  Manager.prototype.rl = null;
};
getSTDIN.open = function open() {
  Manager.prototype.rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
};
var stdin_default = getSTDIN;

// /Users/orisarfati/node_modules/chalk/source/vendor/ansi-styles/index.js
var assembleStyles = function() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
};
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// /Users/orisarfati/node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
var hasFlag = function(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
var envForceColor = function() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
};
var translateLevel = function(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
};
var _supportsColor = function(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if (("TF_BUILD" in env) && ("AGENT_NAME" in env)) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (("GITHUB_ACTIONS" in env) || ("GITEA_ACTIONS" in env)) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
};
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// /Users/orisarfati/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// /Users/orisarfati/node_modules/chalk/source/index.js
var createChalk = function(options) {
  return chalkFactory(options);
};
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open2, close2, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open2;
    closeAll = close2;
  } else {
    openAll = parent.openAll + open2;
    closeAll = close2 + parent.closeAll;
  }
  return {
    open: open2,
    close: close2,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? "" : string;
  }
  let styler = self[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/runtime/environment.ts
function createGlobalEnv() {
  const env2 = new Environment;
  env2.declareVar("true", MK_BOOL(true), true);
  env2.declareVar("false", MK_BOOL(false), true);
  env2.declareVar("null", MK_NULL(), true);
  env2.declareVar("println", MK_NATIVE_FN((args) => {
    printValues(args);
    return MK_NULL();
  }), true);
  env2.declareVar("exec", MK_NATIVE_FN((args) => {
    const cmd = args[0].value;
    try {
      const result = execSync(cmd, { encoding: "utf-8" });
      return MK_STRING(result.trim());
    } catch (error) {
      throw error;
    }
  }), true);
  env2.declareVar("input", MK_NATIVE_FN((data) => {
    let value = "";
    stdin_default(data[0].value).then((input) => value = input).catch(console.error);
    stdin_default.close();
    return MK_STRING(value);
  }), true);
  env2.declareVar("math", MK_OBJECT(new Map().set("pi", Math.PI).set("sqrt", MK_NATIVE_FN((args) => {
    const arg = args[0].value;
    return MK_NUMBER(Math.sqrt(arg));
  })).set("random", MK_NATIVE_FN((args) => {
    const arg1 = args[0].value;
    const arg2 = args[1].value;
    const min = Math.ceil(arg1);
    const max = Math.floor(arg2);
    return MK_NUMBER(Math.floor(Math.random() * (max - min + 1)) + min);
  })).set("round", MK_NATIVE_FN((args) => {
    const arg = args[0].value;
    return MK_NUMBER(Math.round(arg));
  })).set("ceil", MK_NATIVE_FN((args) => {
    const arg = args[0].value;
    return MK_NUMBER(Math.ceil(arg));
  })).set("abs", MK_NATIVE_FN((args) => {
    const arg = args[0].value;
    return MK_NUMBER(Math.abs(arg));
  }))), true);
  env2.declareVar("http", MK_OBJECT(new Map().set("get", MK_NATIVE_FN((url) => {
    const req = {
      req: url[0].value,
      json: () => {
      },
      text: () => ""
    };
    return MK_OBJECT(new Map().set("json", MK_NATIVE_FN(() => {
      return MK_STRING(JSON.stringify(req.json()));
    })).set("text", MK_NATIVE_FN(() => {
      return MK_STRING(req.text());
    })).set("code", MK_NUMBER(0)).set("ok", MK_BOOL(false)));
  }))), true);
  env2.declareVar("error", MK_NATIVE_FN((message) => {

    class BussinError {
      message;
      constructor(message2) {
        this.message = `${source_default.red("error")}: ${message2}`;
      }
    }
    console.log(new BussinError(message[0].value).message);
    return MK_NULL();
  }), true);
  env2.declareVar("strcon", MK_NATIVE_FN((args, env3) => {
    let res = "";
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      res += arg.value;
    }
    return MK_STRING(res);
  }), true);
  env2.declareVar("format", MK_NATIVE_FN((args, env3) => {
    const str = args.shift();
    let res = "";
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      res = str.value.replace(/\${}/, arg.value);
    }
    if (!args[0])
      throw "2nd parameter in format! missing.";
    return MK_STRING(res);
  }), true);
  function timeFunction(args, env3) {
    return MK_NUMBER(Date.now());
  }
  env2.declareVar("time", MK_NATIVE_FN(timeFunction), true);
  return env2;
}

class Environment {
  parent;
  variables;
  constants;
  constructor(parentENV) {
    const global = parentENV ? true : false;
    this.parent = parentENV;
    this.variables = new Map;
    this.constants = new Set;
  }
  declareVar(varname, value, constant) {
    if (this.variables.has(varname)) {
      throw `Cannot declare variable ${varname}. As it already is defined.`;
    }
    this.variables.set(varname, value);
    if (constant)
      this.constants.add(varname);
    return value;
  }
  assignVar(varname, value) {
    const env2 = this.resolve(varname);
    if (env2.constants.has(varname)) {
      throw `Cannot reassign to variable "${varname}" as it's constant.`;
    }
    env2.variables.set(varname, value);
    return value;
  }
  lookupOrMutObject(expr, value, property) {
    if (expr.object.kind === "MemberExpr")
      return this.lookupOrMutObject(expr.object, value, expr.property);
    const varname = expr.object.symbol;
    const env2 = this.resolve(varname);
    let pastVal = env2.variables.get(varname);
    const prop = property ? property.symbol : expr.property.symbol;
    const currentProp = expr.property.symbol;
    if (currentProp)
      pastVal = pastVal.properties.get(currentProp);
    if (value)
      pastVal.properties.set(prop, value);
    return pastVal;
  }
  lookupVar(varname) {
    const env2 = this.resolve(varname);
    return env2.variables.get(varname);
  }
  resolve(varname) {
    if (this.variables.has(varname))
      return this;
    if (this.parent == undefined) {
      this.error(`Can't find ${varname}`);
      return this;
    }
    return this.parent.resolve(varname);
  }
  error(message) {
    return console.log(`${source_default.red("error")}: ${message}`);
  }
}

// src/runtime/eval/expressions.ts
function eval_numeric_binary_expr(lhs, rhs, operator) {
  if (operator === "!=") {
    return equals(lhs, rhs, false);
  } else if (operator === "==") {
    return equals(lhs, rhs, true);
  } else if (operator === "&&") {
    return equals(lhs, rhs, true);
  } else if (operator === "|") {
    const llhs = lhs;
    const rrhs = rhs;
    return MK_BOOL(llhs.value || rrhs.value);
  } else if (lhs.type === "number" && rhs.type === "number") {
    const llhs = lhs;
    const rrhs = rhs;
    switch (operator) {
      case "+":
        return MK_NUMBER(llhs.value + rrhs.value);
      case "-":
        return MK_NUMBER(llhs.value - rrhs.value);
      case "*":
        return MK_NUMBER(llhs.value * rrhs.value);
      case "/":
        return MK_NUMBER(llhs.value / rrhs.value);
      case "%":
        return MK_NUMBER(llhs.value % rrhs.value);
      case "<":
        return MK_BOOL(llhs.value < rrhs.value);
      case ">":
        return MK_BOOL(llhs.value > rrhs.value);
      default:
        throw `Unknown operator provided in operation: ${lhs}, ${rhs}.`;
    }
  } else {
    return MK_NULL();
  }
}
var equals = function(lhs, rhs, strict) {
  const compare = strict ? (a, b) => a === b : (a, b) => a !== b;
  switch (lhs.type) {
    case "boolean":
      return MK_BOOL(compare(lhs.value, rhs.value));
    case "number":
      return MK_BOOL(compare(lhs.value, rhs.value));
    case "string":
      return MK_BOOL(compare(lhs.value, rhs.value));
    case "fn":
      return MK_BOOL(compare(lhs.body, rhs.body));
    case "native-fn":
      return MK_BOOL(compare(lhs.call, rhs.call));
    case "null":
      return MK_BOOL(compare(lhs.value, rhs.value));
    case "object":
      return MK_BOOL(compare(lhs.properties, rhs.properties));
    default:
      throw `Unhandled type in: ${lhs}, ${rhs}`;
  }
};
function eval_binary_expr(binop, env2) {
  const lhs = evaluate(binop.left, env2);
  const rhs = evaluate(binop.right, env2);
  return eval_numeric_binary_expr(lhs, rhs, binop.operator);
}
function eval_identifier(ident, env2) {
  const val = env2.lookupVar(ident.symbol);
  return val;
}
function eval_assignment(node, env2) {
  if (node.assigne.kind === "MemberExpr")
    return eval_member_expr(env2, node);
  if (node.assigne.kind !== "Identifier")
    throw `Invalid left-hand-side expression: ${JSON.stringify(node.assigne)}.`;
  const varname = node.assigne.symbol;
  return env2.assignVar(varname, evaluate(node.value, env2));
}
function eval_object_expr(obj, env2) {
  const object = { type: "object", properties: new Map };
  for (const { key, value } of obj.properties) {
    const runtimeVal = value == undefined ? env2.lookupVar(key) : evaluate(value, env2);
    object.properties.set(key, runtimeVal);
  }
  return object;
}
function eval_call_expr(expr, env2) {
  const args = expr.args.map((arg) => evaluate(arg, env2));
  const fn = evaluate(expr.caller, env2);
  if (fn.type == "native-fn") {
    const result = fn.call(args, env2);
    return result;
  }
  if (fn.type == "fn") {
    const func = fn;
    const scope = new Environment(func.declarationEnv);
    for (let i = 0;i < func.parameters.length; i++) {
      const varname = func.parameters[i];
      scope.declareVar(varname, args[i], false);
    }
    let result = MK_NULL();
    for (const stmt of func.body) {
      result = evaluate(stmt, scope);
    }
    return result;
  }
  throw "Cannot call value that is not a function: " + JSON.stringify(fn);
}
function eval_member_expr(env2, node, expr) {
  if (expr) {
    const variable = env2.lookupOrMutObject(expr);
    return variable;
  } else if (node) {
    const variable = env2.lookupOrMutObject(node.assigne, evaluate(node.value, env2));
    return variable;
  } else {
    throw `Evaluating a member expression is not possible without a member or assignment expression.`;
  }
}

// src/runtime/eval/statements.ts
function eval_program(program, env2) {
  let lastEvaluated = MK_NULL();
  for (const statement of program.body) {
    lastEvaluated = evaluate(statement, env2);
  }
  return lastEvaluated;
}
function eval_val_declaration(declaration, env2) {
  const value = declaration.value ? evaluate(declaration.value, env2) : MK_NULL();
  return env2.declareVar(declaration.identifier, value, declaration.constant);
}
function eval_function_declaration(declaration, env2) {
  const fn = {
    type: "fn",
    name: declaration.name,
    parameters: declaration.parameters,
    declarationEnv: env2,
    body: declaration.body
  };
  return env2.declareVar(declaration.name, fn, true);
}
function eval_if_statement(declaration, env2) {
  const test = evaluate(declaration.test, env2);
  if (test.value === true) {
    return eval_body(declaration.body, env2);
  } else if (declaration.alternate) {
    return eval_body(declaration.alternate, env2);
  } else {
    return MK_NULL();
  }
}
var eval_body = function(body, env2, newEnv = true) {
  let scope;
  if (newEnv) {
    scope = new Environment(env2);
  } else {
    scope = env2;
  }
  let result = MK_NULL();
  for (const stmt of body) {
    result = evaluate(stmt, scope);
  }
  return result;
};
function eval_for_statement(declaration, env2) {
  env2 = new Environment(env2);
  eval_val_declaration(declaration.init, env2);
  const body = declaration.body;
  const update = declaration.update;
  let test = evaluate(declaration.test, env2);
  if (test.value !== true)
    return MK_NULL();
  do {
    eval_assignment(update, env2);
    eval_body(body, env2, false);
    test = evaluate(declaration.test, env2);
  } while (test.value);
  return MK_NULL();
}
function eval_try_catch_statement(env2, declaration) {
  const try_env = new Environment(env2);
  const catch_env = new Environment(env2);
  try {
    return eval_body(declaration.body, try_env, false);
  } catch (e) {
    env2.assignVar("error", e);
    return eval_body(declaration.alternate, catch_env, false);
  }
}

// src/runtime/interpreter.ts
function evaluate(astNode, env2) {
  switch (astNode.kind) {
    case "NumericLiteral":
      return { value: astNode.value, type: "number" };
    case "StringLiteral":
      return { value: astNode.value, type: "string" };
    case "Identifier":
      return eval_identifier(astNode, env2);
    case "ObjectLiteral":
      return eval_object_expr(astNode, env2);
    case "CallExpr":
      return eval_call_expr(astNode, env2);
    case "AssignmentExpr":
      return eval_assignment(astNode, env2);
    case "BinaryExpr":
      return eval_binary_expr(astNode, env2);
    case "Program":
      return eval_program(astNode, env2);
    case "IfStatement":
      return eval_if_statement(astNode, env2);
    case "ForStatement":
      return eval_for_statement(astNode, env2);
    case "MemberExpr":
      return eval_member_expr(env2, null, astNode);
    case "TryCatchStatement":
      return eval_try_catch_statement(env2, astNode);
    case "VarDeclaration":
      return eval_val_declaration(astNode, env2);
    case "FunctionDeclaration":
      return eval_function_declaration(astNode, env2);
    default:
      console.error("This AST node has not yet been setup for interpretation", astNode);
      process.exit(0);
  }
}

// src/main.ts
import {readFileSync} from "fs";

// src/utils/currency.ts
var import_currency_symbol_map = __toESM(require_currency_symbol_map(), 1);
async function getLocalCurrency() {
  const cSymbol = await (await fetch("https://ipapi.co/currency/")).text();
  return import_currency_symbol_map.default(cSymbol);
}

// src/utils/transcriber.ts
async function transcribe(code, bsx) {
  const currency2 = await getLocalCurrency();
  if (bsx) {
    return code.replace_fr("rn", ";").replace_fr(";", "!").replace_fr("be", "=").replace_fr("lit", "let").replace_fr("mf", "const").replace_fr("waffle", "println").replace_fr("sus", "if").replace_fr("impostor", "else").replace_fr("nah", "!=").replace_fr("fr", "==").replace_fr("btw", "&&").replace_fr("carenot", "|").replace_fr("bruh", "fn").replace_fr("nerd", "math").replace_fr("yall", "for").replace_fr("smol", "<").replace_fr("thicc", ">").replace_fr("nocap", "true").replace_fr("cap", "false").replace_fr("fuck_around", "try").replace_fr("find_out", "catch").replace_fr("clapback", "exec").replace_fr("minus", "-").replace_fr("plus", "+").replace_fr("times", "*").replace_fr("divided by", "/").replace_fr("yeet", "throw").replace_fr("rizz", "error").replace(/\: number/g, "").replace(/\: string/g, "").replace(/\: object/g, "").replace(/\: boolean/g, "").replace(/[a-zA-Z].\.{1,}[a-zA-Z]/g, "").replace(new RegExp(`${currency2}{}`), "${}").replace(new RegExp(`{}${currency2}`), "${}");
  } else {
    return code.replace(/\: number/g, "").replace(/\: string/g, "").replace(/\: object/g, "").replace(/\: boolean/g, "").replace(/[a-zA-Z].\.{1,}[a-zA-Z]/g, "").replace(new RegExp(`${currency2}{}`), "${}").replace(new RegExp(`{}${currency2}`), "${}");
  }
}
String.prototype.replace_fr = function(target, replacement) {
  const pattern = new RegExp('(?<![\'"`])\\b' + target + '\\b(?!["\'`])', "g");
  return this.replace(pattern, replacement);
};

// src/main.ts
async function run(filename) {
  await fetch("https://8.8.8.8");
  const parser2 = new Parser;
  const env2 = createGlobalEnv();
  let input = readFileSync(filename, "utf-8");
  filename.endsWith(".bsx") ? input = await transcribe(input, true) : input = await transcribe(input, false);
  const program = parser2.produceAST(input);
  const result = evaluate(program, env2);
  return result;
}
async function repl(arg) {
  if (typeof globalThis.Deno === "undefined" && typeof globalThis.Bun === "undefined") {
    await fetch("https://8.8.8.8");
  }
  const parser2 = new Parser;
  const env2 = createGlobalEnv();
  console.log("Repl v1.0 (Bussin)");
  while (true) {
    let input = "";
    if (!stdin_default.closed) {
      input = await stdin_default("> ");
    } else {
      stdin_default.open();
      input = await stdin_default("> ");
    }
    if (input === "exit()") {
      process.exit(1);
    }
    input = await transcribe(input, arg !== "--bsx" ? false : true);
    const program = parser2.produceAST(input);
    const result = evaluate(program, env2);
    if (!result) {
      continue;
    } else {
      if (result.constructor === Object) {
        if (typeof result.value === "string") {
          console.log(source_default.green(`'${result.value}'`));
        } else if (typeof result.value === "number") {
          if (isNaN(result.value)) {
            console.log();
          } else {
            console.log(source_default.yellow(`${result.value}`));
          }
        } else if (typeof result.value === "boolean") {
          console.log(source_default.yellow(`${result.value}`));
        } else {
          console.log();
        }
      } else {
        console.log();
      }
    }
  }
}
var file = process.argv[2] && !process.argv[2].startsWith("-") && process.argv[2];
if (file) {
  run(file);
} else if (process.argv[2]) {
  repl(process.argv[2]);
} else {
  repl();
}
